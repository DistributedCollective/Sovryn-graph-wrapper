# Settlement contract scaffolded events (for Limit Orders)

type Deposit @entity {
  id: ID!
  to: String! # address
  amount: String! # uint256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

type MarginOrderCanceled @entity {
  id: ID!
  hash: String! # String32
  trader: String! # address
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

type MarginOrderFilled @entity {
  id: ID!
  hash: String! # String32
  trader: User! # address
  principal: String! # uint256
  collateral: String! # uint256
  leverageAmount: String! # uint256
  loanTokenAddress: String! # address
  loanTokenSent: String! # uint256
  collateralTokenSent: String! # uint256
  collateralTokenAddress: String! # address
  filledPrice: String! # uint256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

type OrderCanceled @entity {
  id: ID!
  hash: String! # String32
  maker: String! # address
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

type OrderFilled @entity {
  id: ID!
  hash: String! # String32
  maker: User! # address
  amountIn: String! # uint256
  amountOut: String! # uint256
  path: [String!]! # address[]
  filledPrice: String! # uint256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

type Withdrawal @entity {
  id: ID!
  receiver: String! # address
  amount: String! # uint256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

# AMM SCHEMA

"""
The ConverterRegistry registers each new AMM pool added to the Sovryn Protocol
"""
type ConverterRegistry @entity {
  """
  ID is the address of the converter registry contract
  """
  id: ID!
  """
  All the converters (AMM pools) associated with this registry
  """
  converters: [LiquidityPool!] @derivedFrom(field: "currentConverterRegistry")
  smartTokens: [SmartToken!] @derivedFrom(field: "currentConverterRegistry")
  connectorTokens: [Token!] @derivedFrom(field: "currentConverterRegistry")
  owner: String! # address
  addedToContractRegistryAtBlockTimestamp: String
  addedToContractRegistryAtTransactionHash: String
  addedToContractRegistryAtBlockNumber: String
  lastUsedAtBlockTimestamp: String
  lastUsedAtTransactionHash: String
  lastUsedAtBlockNumber: String
  numConverters: String!
}

"""
The smart token represents a single reserve asset on a single pool.
For V1 pools, there is 1 smart token representing both reserve assets. For V2 pools, there are 2 smart tokens, one for each reserve asset.
"""
type SmartToken @entity {
  """
  ID is smart token address
  """
  id: ID!
  name: String
  symbol: String
  decimals: Int
  version: Int
  """
  smartTokenType can be Relay or Liquid
  """
  smartTokenType: String # Relay, Liquid, BNT?, Others?
  transfersEnabled: Boolean
  """
  The AMM pool this smart token "belongs" to
  """
  liquidityPool: LiquidityPool! @derivedFrom(field: "smartToken")
  """
  connectorTokens are the entity that holds the many-to-many relationship between the underlying token asset and the smart token
  """
  connectorTokens: [TokenSmartToken!] @derivedFrom(field: "smartToken")
  owner: String!
  # tokenSwapTotals: [TokenSwapTotal!] @derivedFrom(field: "toToken")
  currentConverterRegistry: ConverterRegistry
  addedToRegistryBlockNumber: String
  addedToRegistryTransactionHash: String
}

"""
This entity is to store a many-to-many relationship between tokens and smart tokens
"""
type TokenSmartToken @entity {
  """
  ID is token address + smart token address
  """
  id: ID!
  """
  token is the underlying asset represented by the smartToken
  """
  token: Token!
  smartToken: SmartToken!
}

"""
For the V1 pools, the pool token and smart token are the same. However, for V2 pools, there is one pool token per asset and only one smart token for the pool.
"""
type PoolToken @entity {
  id: ID!
  name: String
  symbol: String
  decimals: Int
  converters: [LiquidityPoolToken!] @derivedFrom(field: "poolToken") #TODO: Does this need a many-to-many relationship?
  underlyingAssets: [TokenPoolToken!] @derivedFrom(field: "poolToken")
}

"""
The Swap entity is an aggregated entity of the individual Conversion events in a transaction.
For example, if a User swaps XUSD to SOV, there will be 2 Conversion events through 2 AMMs (XUSD-BTC and BTC-SOV) in one transaction. These two Conversions are aggregated here.
"""
type Swap @entity {
  """
  Transaction hash of this swap
  """
  id: ID!
  """
  The AMM Conversion events involved in this swap
  """
  conversions: [Conversion!] @derivedFrom(field: "swapTransaction")
  """
  The number of AMM Conversions involved in this swap (this is primarily for debugging purposes)
  """
  numConversions: Int!
  fromToken: Token!
  toToken: Token!
  fromAmount: String!
  toAmount: String!
  """
  Rate is calculated as toAmount / fromAmount
  """
  rate: String!
  """
  If this swap was initiated by a contract (for example as part of a Margin Trade), User will be null
  """
  user: User
  """
  Was this swap part of a margin trade?
  """
  isMarginTrade: Boolean!
  isBorrow: Boolean!
  """
  Was this swap a limit order?
  """
  isLimit: Boolean!
  timestamp: String!
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted. Although this is pretty useful, maybe keep
"""
type Conversion @entity {
  id: ID!
  _fromToken: Token! # address
  _toToken: Token! # address
  _trader: String! # address
  _amount: String! # uint256
  _return: String! # uint256
  _conversionFee: String! # int256
  _protocolFee: String! # int256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
  swapTransaction: Swap!
}

"""
AMM Pool (sometimes referred to as a Converter)
"""
type LiquidityPool @entity {
  """
  ID is the contract address of the Converter
  """
  id: ID!
  """
  Sovryn uses Bancor V1 and Bancor V2 pools
  """
  type: Int
  version: Int
  smartToken: SmartToken
  """
  The reserve assets of this AMM Pool. The are stored here like this so that they can be accessed inside mappings when the LiquidityPool is loaded.
  """
  token0: Token
  token1: Token
  connectorTokens: [LiquidityPoolToken!]! @derivedFrom(field: "liquidityPool")
  poolTokens: [TokenPoolToken!]! @derivedFrom(field: "liquidityPool")
  owner: String
  conversionFee: String
  weight: String
  """
  Activated with be true when this pool is activated, and will change to false is the pool is deactivated
  """
  activated: Boolean
  # hasRBTCReserve: Boolean!
  maxConversionFee: String
  # reserveRatio: Int!
  # activated: Boolean!
  # numSwaps: String!
  lastResetBlockNumber: String
  lastResetTimestamp: String
  createdAtTimestamp: String
  createdAtBlockNumber: String
  createdAtTransaction: Transaction!
  currentConverterRegistry: ConverterRegistry
  # OTHER FIELDS TO ADD HERE
}

"""
This entity stores the relationship between liquidity pools and underlying tokens
It also currently stores the total volumes bought and so
"""
type LiquidityPoolToken @entity {
  """
  ID is liquidityPool address + tokenAddress
  """
  id: ID!
  token: Token!
  liquidityPool: LiquidityPool!
  """
  The pool token that represents this token-liquidityPool relationship
  """
  poolToken: PoolToken!
  # balance: String! # Balance is hard to implement because pools were initially funded not through the LiquidityAdded event
  volumeBought: String!
  volumeSold: String!
  totalVolume: String!
}

"""
The entity stores the many-to-many relationship between underlying tokens and pool tokens
"""
type TokenPoolToken @entity {
  """
  ID is token address + poolToken address
  """
  id: ID!
  token: Token!
  poolToken: PoolToken!
  liquidityPool: LiquidityPool!
}

#### GENERATED BY SCAFFOLD SCRIPT - Add any custom entities before this line

type NewConverter @entity {
  id: ID!
  _type: Int! # uint16
  _converter: String! # address
  _owner: String! # address
  timestamp: String!
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type LiquidityPoolAdded @entity {
  id: ID!
  _liquidityPool: String! # address
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type LiquidityPoolRemoved @entity {
  id: ID!
  _liquidityPool: String! # address
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type SmartTokenAdded @entity {
  id: ID!
  _smartToken: String! # address
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Autogenerated for debugging - to be eventually deleted
"""
type SmartTokenRemoved @entity {
  id: ID!
  _smartToken: String! # address
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

# Candlesticks

type CandleStick @entity {
  id: ID! # fromToken + toToken + timestamp + interval
  baseToken: Token
  quoteToken: Token
  interval: CandleSticksInterval
  open: String # opening price
  high: String! # high price
  low: String! # low price
  close: String! # close price
  txCount: Int! # number of transactions during period
  totalVolume: String! # total volume in quote currency
  periodStartUnix: Int! # unix timestamp for start of candle
}

enum CandleSticksInterval {
  MinuteInterval
  FifteenMintuesInterval
  HourInterval
  FourHourInterval
  DayInterval
}

# Governor Contracts
type Proposal @entity {
  id: ID! # contract address + id
  created: Transaction!
  canceled: Transaction
  executed: Transaction
  queued: Transaction
  votesFor: String!
  votesAgainst: String!
  countVotersFor: String!
  countVotersAgainst: String!
  votes: [VoteCast!] @derivedFrom(field: "proposal")
  proposalId: String!
  proposer: String! # address
  targets: [String!]! # address[]
  values: [String!]! # uint256[]
  signatures: [String!]! # string[]
  startBlock: String! # uint256
  endBlock: String! # uint256
  description: String! # string
  timestamp: String!
  emittedBy: String! #address
}

type VoteCast @entity {
  id: ID!
  voter: User! # address
  proposalId: String! # uint256
  proposal: Proposal!
  support: Boolean! # bool
  votes: String! # uint256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
A Lending Pool (iToken), where Users can lend assets to earn interest, and Users can borrow assets to Margin Trade or just as a regular loan.
"""
type LendingPool @entity {
  """
  ID is the contract address of the iToken
  """
  id: ID!
  """
  The actual asset being lent and borrowed in this pool
  """
  underlyingAsset: Token!
  poolTokenBalance: String!
  assetBalance: String!
  """
  Total asset volume lent over all time
  """
  totalAssetLent: String!
}

"""
This entity contains the lending and unlending history of one User
"""
type UserLendingHistory @entity {
  """
  ID is userAddress + lendingPoolAddress (lendingPool in this case is the lending pool token)
  """
  id: ID!
  user: User!
  lendingPool: LendingPool!
  """
  Granular Lend/UnLend events. Derived from Mint/Burn events on the contracts
  """
  lendingHistory: [LendingHistoryItem!]
    @derivedFrom(field: "userLendingHistory")
  """
  Total volume this User has lent to this pool over all time (in the underlying asset currency, ie rBTC for the rBTC lending pool)
  """
  totalLendVolume: String!
  """
  Total volume this User has withdrawn from this pool over all time
  """
  totalUnlendVolume: String!
}

enum LendingHistoryType {
  Lend
  UnLend
}

type LendingHistoryItem @entity {
  id: ID! # tx hash
  lender: User!
  type: LendingHistoryType!
  lendingPool: LendingPool!
  """
  The underlying asset for this pool (eg USDT for the iUSDT pool)
  """
  asset: Token
  amount: String! #TODO: Change to String
  loanTokenAmount: String!
  transaction: Transaction!
  emittedBy: String!
  userLendingHistory: UserLendingHistory!
}

"""
This entity stores one Users history of adding and removing liquidity from one AMM pool
"""
type UserLiquidityHistory @entity {
  id: ID! # user + '-' + smartToken
  user: User!
  poolToken: PoolToken!
  totalAsset0LiquidityAdded: String!
  totalAsset0LiquidityRemoved: String!
  totalAsset1LiquidityAdded: String!
  totalAsset1LiquidityRemoved: String!
  liquidityHistory: [LiquidityHistoryItem!]
    @derivedFrom(field: "userLiquidityHistory")
}

enum LiquidityHistoryType {
  Added
  Removed
}

type LiquidityHistoryItem @entity {
  """
  ID is transaction hash + log index
  """
  id: ID!
  user: User!
  userLiquidityHistory: UserLiquidityHistory!
  type: LiquidityHistoryType! # Added or removed
  provider: String! # address
  reserveToken: Token! # address
  amount: String! # uint256
  newBalance: String! # uint256
  newSupply: String! # uint256
  timestamp: String!
  liquidityPool: LiquidityPool!
  emittedBy: String! #address
  transaction: Transaction!
}

# Loans
enum LoanType {
  Trade
  Borrow
}

"""
A Loan can be initialized by either a Margin Trade event or a Borrow event
"""
type Loan @entity {
  id: ID! # ID is LoanId
  loanToken: Token!
  collateralToken: Token!
  """
  LoanType is either Trade (for Margin Trades) or Borrow (for Borrows)
  """
  type: LoanType!
  startTimestamp: String!
  endTimestamp: String
  """
  The amount borrowed in loan tokens
  """
  borrowedAmount: String!
  startBorrowedAmount: String!
  maxBorrowedAmount: String!

  """
  Total of collateral (user collateral in a Borrow, and user collateral + borrowed amount in a Trade) in collateral tokens
  """
  positionSize: String!
  """
  Initial size of the position
  """
  startPositionSize: String!
  """
  The maximum this position size was - mainly for debugging purposes
  """
  maximumPositionSize: String!
  """
  The start rate of the loan in loan tokens (eg if it is a long USD/BTC margin trade, this is the BTC price in USD)
  """
  startRate: String!
  """
  If a Liquidate, CloseWithSwap or CloseWithDeposit event occurs with 0 margin or 0 leverage, this property changes to false
  """
  isOpen: Boolean!
  user: User!
  trade: [Trade!] @derivedFrom(field: "loanId")
  borrow: [Borrow!] @derivedFrom(field: "loanId")
  closeWithSwaps: [CloseWithSwap!] @derivedFrom(field: "loanId")
  closewithDeposits: [CloseWithDeposit!] @derivedFrom(field: "loanId")
  liquidates: [Liquidate!] @derivedFrom(field: "loanId")
  depositCollateral: [DepositCollateral!] @derivedFrom(field: "loanId")
  """
  Sum of position volume from Trade, Borrow and DepositCollateral events in this loan, in collateral token
  """
  totalBought: String!
  """
  Sum of position change volume from CloseWithSwap, CloseWithDeposit and Liquidate events in this loan, in collateral token
  """
  totalSold: String!
  """
  Average price per token from all loan open events
  """
  averageBuyPrice: String!
  """
  Average price per token from all loan close events
  """
  averageSellPrice: String!
  """
  The realized PnL is quoted in the collateral currency
  """
  realizedPnL: String!
  realizedPnLPercent: String!
}

"""
Granular event data for the Loan entity. Emitted when a user Borrows (takes out a loan)
"""
type Borrow @entity {
  id: ID!
  user: User! # address
  lender: String! # address
  loanId: Loan! # String32
  loanToken: String! # address
  collateralToken: String! # address
  newPrincipal: String! # uint256
  newCollateral: String! # uint256
  interestRate: String! # uint256
  interestDuration: String! # uint256
  collateralToLoanRate: String! # uint256
  currentMargin: String! # uint256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Borrow event
"""
type CloseWithDeposit @entity {
  id: ID!
  user: String! # address
  lender: String! # address
  loanId: Loan! # String32
  closer: String! # address
  loanToken: String! # address
  collateralToken: String! # address
  repayAmount: String! # uint256
  collateralWithdrawAmount: String! # uint256
  collateralToLoanRate: String! # uint256
  currentMargin: String! # uint256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Margin Trade
"""
type CloseWithSwap @entity {
  id: ID!
  user: String! # address
  lender: String! # address
  loanId: Loan! # String32
  collateralToken: String! # address
  loanToken: String! # address
  closer: String! # address
  positionCloseSize: String! # uint256
  loanCloseAmount: String! # uint256
  exitPrice: String! # uint256
  currentLeverage: String! # uint256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user closes adds collateral to a Margin Trade or Borrow
"""
type DepositCollateral @entity {
  id: ID!
  loanId: Loan! # String32
  depositAmount: String! # uint256
  rate: String # uint256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a loan is fully or partially liquidated
"""
type Liquidate @entity {
  id: ID!
  user: User! # address
  liquidator: String! # address
  loanId: Loan! # String32
  lender: String! # address
  loanToken: String! # address
  collateralToken: String! # address
  repayAmount: String! # uint256
  collateralWithdrawAmount: String! # uint256
  collateralToLoanRate: String! # uint256
  currentMargin: String! # uint256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user Borrows and when a loan is rolled over
"""
type PayBorrowingFee @entity {
  id: ID!
  payer: String! # address
  token: String! # address
  loanId: Loan! # String32
  amount: String! # uint256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user Lends or Unlends and when a loan is rolled over
"""
type PayLendingFee @entity {
  id: ID!
  payer: String! # address
  token: String! # address
  amount: String! # uint256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

"""
Granular event data for the Loan entity. Emitted when a user Margin Trades and when a loan is rolled over
"""
type PayTradingFee @entity {
  id: ID!
  payer: String! # address
  token: String! # address
  loanId: Loan! # String32
  amount: String! # uint256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

type Trade @entity {
  id: ID!
  user: User!
  lender: String!
  loanId: Loan!
  collateralToken: Token!
  loanToken: Token!
  positionSize: String!
  borrowedAmount: String!
  interestRate: String!
  settlementDate: String!
  entryPrice: String!
  entryLeverage: String!
  currentLeverage: String!
  timestamp: String!
  emittedBy: String!
  transaction: Transaction!
}

# PROTOCOL LEVEL ENTITIES

"""
This entity will have only one instance and will be used to store protocol-wide data like list of tokens and number or users.
The ID of this one entity is "0"
"""
type ProtocolStats @entity {
  """
  Only one entity should be created, with ID "0"
  """
  id: ID!
  """
  An array of all tokens in the protocol
  """
  tokens: [Token!]!
  usdStablecoin: Token!
  btcUsdPrice: String!
  """
  Total number of users of the protocol. This number is incremented each time a user initiates a transaction with the Protocol.
  Currently this is incremented by specific user actions, but could be incremented on a per Transaction basis.
  """
  totalUsers: String!
  """
  Total of positionSize property in Trade event (in usd). This includes user collateral and borrowed amount
  """
  totalMarginTradeVolumeUsd: String!
  """
  Total position volume closed for Margin Trades (in usd)
  """
  totalCloseWithSwapVolumeUsd: String!
  """
  Total additional collateral deposited for Margin Trades and Borrows (in usd)
  """
  totalDepositCollateralVolumeUsd: String!
  """
  Total Margin Trade and Borrow position size that has been liquidated (in usd)
  """
  totalLiquidateVolumeUsd: String!
  """
  Total volume that has passed through every AMM pool of the Sovryn protocol (in usd)
  """
  totalAmmVolumeUsd: String!
  """
  Total volume of fees earned by liquidity providers to AMM pools (in usd)
  """
  totalAmmLpFeesUsd: String!
  """
  Total volume of fees earned by SOV stakers from AMM conversion events (in usd). These fees began after the fee-sharing SIP was executed.
  """
  totalAmmStakerFeesUsd: String!
  """
  Total fees from Margin Trading earned by SOV stakers (in usd)
  """
  totalTradingFeesUsd: String!
  """
  Total fees from Lending and Unlending earned by SOV stakers (in usd)
  """
  totalLendingFeesUsd: String!
  """
  Total fees from Borrowing earned by SOV stakers (in usd)
  """
  totalBorrowingFeesUsd: String!
  """
  Total volume supplied to Lending Pools over all time (in usd)
  """
  totalLendVolumeUsd: String!
  """
  Total volume withdrawn from Lending Pool over all time (in usd)
  """
  totalUnlendVolumeUsd: String!
  """
  Total of collateral property in Trade event (in usd). This may be changed to borrowed amount volume, but collateral keeps it consistent with margin trading
  """
  totalBorrowVolumeUsd: String!
  """
  Total volume of Borrows closed (in usd)
  """
  totalCloseWithDepositVolumeUsd: String!
  """
  This is SOV staked by users (not vesting contracts). It is incremented when users stake tokens, and decremented when users withdraw tokens from the staking contract
  """
  totalVoluntarilyStakedSov: String!
  """
  This is SOV staked by vesting contracts. It in incremented when the contracts stake the tokens, and decremented when users claim their unlocked tokens
  """
  totalStakedByVestingSov: String!
  """
  NOT YET IMPLEMENTED: This will be a total of volumes of all transaction types (AMM Swaps, Margin Trades, CloseWithSwap etc etc)
  """
  totalTransactedVolumeUsd: String! # TODO: Implement
}

"""
Transaction data, including hash and timestamp
"""
type Transaction @entity {
  """
  ID is transaction hash
  """
  id: ID!
  blockNumber: String!
  """
  The timestamp the transaction was confirmed
  """
  timestamp: String!
  gasPrice: String!
  """
  The index of this transaction within the block
  """
  index: String!
  """
  The account that initiated this transaction. This must be an Account and not a Contract.
  """
  from: String! # TODO: Change to User entity
  to: String
  value: String!
  gasLimit: String!
}

"""
This entity represents an ERC20 token traded on the Sovryn Protocol
"""
type Token @entity {
  """
  The ID is the contract address of the token on RSK
  """
  id: ID!
  name: String
  symbol: String
  decimals: Int
  version: Int
  """
  The addresses of the LiquidityPools where this token is a reserve asset
  """
  liquidityPools: [LiquidityPoolToken!] @derivedFrom(field: "token")
  """
  The smart tokens that have this token as an underlying asset
  """
  smartTokens: [TokenSmartToken!] @derivedFrom(field: "token")
  # tokenSwapTotals: [TokenSwapTotals!]
  """
  previous BTC price used for candleSticks
  """
  prevPriceBtc: String!
  lastPriceBtc: String!
  """
  previous BTC price used for candleSticks
  """
  prevPriceUsd: String!
  lastPriceUsd: String!
  """
  The total volume of this token that has been traded through the protocol quoted in BTC
  """
  btcVolume: String!
  """
  The total volume of this token that has been traded through the protocol quoted in USD
  """
  usdVolume: String!
  """
  The total volume of this token that has been traded through the protocol
  """
  tokenVolume: String!
  # marketCap: String!
  # circulatingSupply: String!
  currentConverterRegistry: ConverterRegistry
  """
  Does this token have an AMM pool with rBTC as the other reserve asset?
  """
  hasBtcPool: Boolean
  """
  Does this token have an AMM pool with the protocol stablecoin as the other reserve asset?
  """
  hasStablecoinPool: Boolean
}

"""
This entity contains the history, fees and totals regarding one users' SOV rewards
"""
type UserRewardsEarnedHistory @entity {
  id: ID! # user
  user: User!
  """
  This is the total of all EarnReward and RewardClaimed events
  """
  totalFeesAndRewardsEarned: String!
  """
  This is incremented by EarnReward events, and set to 0 by TokensStaked events on the LockedSOV contract
  """
  availableTradingRewards: String!
  """
  This is incremented by EarnReward and RewardClaimed events, and set to 0 by RewardWithdrawn events
  """
  availableRewardSov: String!
  rewardsEarnedHistory: [RewardsEarnedHistoryItem!] @derivedFrom(field: "user")
}

enum RewardsEarnedAction {
  StakingRewardWithdrawn
  EarnReward
  RewardClaimed
  RewardSovStaked
}

type RewardsEarnedHistoryItem @entity {
  id: ID! # transaction hash
  action: RewardsEarnedAction!
  user: UserRewardsEarnedHistory!
  token: Token
  amount: String!
  timestamp: String!
  transaction: Transaction!
}

type TokensStaked @entity {
  id: ID!
  user: User
  staker: String! # address
  amount: String! # uint256
  lockedUntil: String! # uint256
  totalStaked: String! # uint256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
  isUserStaked: Boolean!
}

# This maps to existing stakeHistory api

type UserStakeHistory @entity {
  id: ID! # id is user
  user: User!
  stakeHistory: [StakeHistoryItem!] @derivedFrom(field: "user")
  totalStaked: String!
  totalWithdrawn: String!
  totalRemaining: String!
}

enum StakeHistoryAction {
  Stake
  IncreaseStake
  ExtendStake
  Delegate
  Unstake
  WithdrawStaked
  FeeWithdrawn
}

type StakeHistoryItem @entity {
  id: ID! # transaction hash
  user: UserStakeHistory!
  action: StakeHistoryAction!
  timestamp: String!
  transaction: Transaction!
  amount: String
  lockedUntil: String
}

# This event is emitted when tokens are transferred to the Protocol contract as fees
# It is needed because this is a flag for if staked tokens were unstaked early

type FeeSharingTokensTransferred @entity {
  id: ID! # ID is tx hash - it can't be tx hash + log index because we need to load on tx hash
  sender: String!
  token: String!
  amount: String!
}

# USER SCHEMA

"""
This entity contains all user-specific data displayed on the dapp, including all user actions
"""
type User @entity {
  """
  ID is user wallet address
  """
  id: ID!
  """
  Swaps here refers to only user-triggered swaps. For example, a swap that is part of a margin trade would not be included.
  Swaps involving multiple amm pools are stored as a single swap, comprised of multiple Conversion events
  """
  swaps: [Swap!] @derivedFrom(field: "user")
  """
  An array of all LiquidityAdded and LiquidityRemoved events
  """
  liquidityHistory: [UserLiquidityHistory!] @derivedFrom(field: "user")
  """
  An array of margin trade Trade events
  """
  trades: [Trade!] @derivedFrom(field: "user")
  """
  An array of Borrow events
  """
  borrows: [Borrow!] @derivedFrom(field: "user")
  """
  An array of Liquidation events linked to this user
  """
  liquidations: [Liquidate!] @derivedFrom(field: "user")
  """
  All loans taken out by this user, including for margin trading and for borrowing
  """
  loans: [Loan!] @derivedFrom(field: "user")
  """
  The lending history of a User, separated into lending pools. Explore the UserLendingHistory entity for more granular events.
  """
  lendingHistory: [UserLendingHistory!] @derivedFrom(field: "user")
  """
  The SOV Staking history of a user. This includes withdrawing vested tokens. Explore the UserStakeHistory entity for more granular events.
  """
  stakeHistory: [UserStakeHistory!] @derivedFrom(field: "user")
  """
  The Rewards history of one user. This includes actions like EarnReward, RewardSovDeposited, and RewardSovStaked.
  Explore the UserRewardsEarnedHistory entity for more granular events
  """
  rewardsEarnedHistory: [UserRewardsEarnedHistory!] @derivedFrom(field: "user")
  """
  Vesting contracts owned by User, labelled by type
  """
  vestingContracts: [VestingContract!] @derivedFrom(field: "user")
  """
  Voting history of User
  """
  votes: [VoteCast!] @derivedFrom(field: "voter")
  """
  See UserTotals entity for full documentation
  """
  userTotals: UserTotal @derivedFrom(field: "user")
}

"""
This is the total volumes of different actions for one user. See ProtocolStats entity for full descriptions.
"""
type UserTotal @entity {
  id: ID!
  user: User!
  totalMarginTradeVolumeUsd: String!
  totalCloseWithSwapVolumeUsd: String!
  totalDepositCollateralVolumeUsd: String!
  totalLiquidateVolumeUsd: String!
  totalAmmVolumeUsd: String!
  totalAmmLpFeesUsd: String!
  totalAmmStakerFeesUsd: String!
  totalTradingFeesUsd: String!
  totalLendingFeesUsd: String!
  totalBorrowingFeesUsd: String!
  totalLendVolumeUsd: String!
  totalUnlendVolumeUsd: String!
  totalBorrowVolumeUsd: String!
  totalCloseWithDepositVolumeUsd: String!
  # totalTransactedVolumeUsd: String! # TODO: Implement
}

# Vesting Resistry

enum VestingContractType {
  Origins
  Genesis
  Fish
  FishTeam
  Team
  Rewards
}

type VestingContract @entity {
  id: ID! # vesting contract id
  user: User!
  createdAtTimestamp: String!
  cliff: String # uint256
  duration: String # uint256
  startingBalance: String! # uint256
  currentBalance: String!
  type: VestingContractType!
  emittedBy: String!
  createdAtTransaction: Transaction!
  stakeHistory: [VestingHistoryItem!] @derivedFrom(field: "staker")
}

enum VestingHistoryItemAction {
  TokensStaked
  TeamTokensRevoked
  TokensWithdrawn
}

type VestingHistoryItem @entity {
  id: ID!
  action: VestingHistoryItemAction!
  staker: VestingContract!
  amount: String! # uint256
  lockedUntil: String! # uint256
  totalStaked: String! # uint256
  timestamp: String!
  emittedBy: String! #address
  transaction: Transaction!
}

type Query {
  liquidityPools: [LiquidityPool]
  liquidityPool: LiquidityPool
  transactions: [Transaction]
  transaction: Transaction
}
