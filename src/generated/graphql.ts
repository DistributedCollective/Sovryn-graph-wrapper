/* eslint-disable */

import { GraphQLResolveInfo } from "graphql";
import gql from "graphql-tag";
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export interface Scalars {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
}

/** Granular event data for the Loan entity. Emitted when a user Borrows (takes out a loan) */
export interface Borrow {
  __typename?: "Borrow";
  collateralToLoanRate: Scalars["String"];
  collateralToken: Scalars["String"];
  currentMargin: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  interestDuration: Scalars["String"];
  interestRate: Scalars["String"];
  lender: Scalars["String"];
  loanId: Loan;
  loanToken: Scalars["String"];
  newCollateral: Scalars["String"];
  newPrincipal: Scalars["String"];
  timestamp: Scalars["String"];
  transaction: Transaction;
  user: User;
}

export interface CandleStick {
  __typename?: "CandleStick";
  baseToken?: Maybe<Token>;
  close: Scalars["String"];
  high: Scalars["String"];
  id: Scalars["ID"];
  interval?: Maybe<CandleSticksInterval>;
  low: Scalars["String"];
  open?: Maybe<Scalars["String"]>;
  periodStartUnix: Scalars["Int"];
  quoteToken?: Maybe<Token>;
  totalVolume: Scalars["String"];
  txCount: Scalars["Int"];
}

export enum CandleSticksInterval {
  DayInterval = "DayInterval",
  FifteenMintuesInterval = "FifteenMintuesInterval",
  FourHourInterval = "FourHourInterval",
  HourInterval = "HourInterval",
  MinuteInterval = "MinuteInterval",
}

/** Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Borrow event */
export interface CloseWithDeposit {
  __typename?: "CloseWithDeposit";
  closer: Scalars["String"];
  collateralToLoanRate: Scalars["String"];
  collateralToken: Scalars["String"];
  collateralWithdrawAmount: Scalars["String"];
  currentMargin: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  lender: Scalars["String"];
  loanId: Loan;
  loanToken: Scalars["String"];
  repayAmount: Scalars["String"];
  timestamp: Scalars["String"];
  transaction: Transaction;
  user: Scalars["String"];
}

/** Granular event data for the Loan entity. Emitted when a user closes a loan initiated by a Margin Trade */
export interface CloseWithSwap {
  __typename?: "CloseWithSwap";
  closer: Scalars["String"];
  collateralToken: Scalars["String"];
  currentLeverage: Scalars["String"];
  emittedBy: Scalars["String"];
  exitPrice: Scalars["String"];
  id: Scalars["ID"];
  lender: Scalars["String"];
  loanCloseAmount: Scalars["String"];
  loanId: Loan;
  loanToken: Scalars["String"];
  positionCloseSize: Scalars["String"];
  timestamp: Scalars["String"];
  transaction: Transaction;
  user: Scalars["String"];
}

/** Autogenerated for debugging - to be eventually deleted. Although this is pretty useful, maybe keep */
export interface Conversion {
  __typename?: "Conversion";
  _amount: Scalars["String"];
  _conversionFee: Scalars["String"];
  _fromToken: Token;
  _protocolFee: Scalars["String"];
  _return: Scalars["String"];
  _toToken: Token;
  _trader: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  swapTransaction: Swap;
  timestamp: Scalars["String"];
  transaction: Transaction;
}

/** The ConverterRegistry registers each new AMM pool added to the Sovryn Protocol */
export interface ConverterRegistry {
  __typename?: "ConverterRegistry";
  addedToContractRegistryAtBlockNumber?: Maybe<Scalars["String"]>;
  addedToContractRegistryAtBlockTimestamp?: Maybe<Scalars["String"]>;
  addedToContractRegistryAtTransactionHash?: Maybe<Scalars["String"]>;
  connectorTokens?: Maybe<Token[]>;
  /** All the converters (AMM pools) associated with this registry */
  converters?: Maybe<LiquidityPool[]>;
  /** ID is the address of the converter registry contract */
  id: Scalars["ID"];
  lastUsedAtBlockNumber?: Maybe<Scalars["String"]>;
  lastUsedAtBlockTimestamp?: Maybe<Scalars["String"]>;
  lastUsedAtTransactionHash?: Maybe<Scalars["String"]>;
  numConverters: Scalars["String"];
  owner: Scalars["String"];
  smartTokens?: Maybe<SmartToken[]>;
}

export interface Deposit {
  __typename?: "Deposit";
  amount: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  timestamp: Scalars["String"];
  to: Scalars["String"];
  transaction: Transaction;
}

/** Granular event data for the Loan entity. Emitted when a user closes adds collateral to a Margin Trade or Borrow */
export interface DepositCollateral {
  __typename?: "DepositCollateral";
  depositAmount: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  loanId: Loan;
  rate?: Maybe<Scalars["String"]>;
  timestamp: Scalars["String"];
  transaction: Transaction;
}

export interface FeeSharingTokensTransferred {
  __typename?: "FeeSharingTokensTransferred";
  amount: Scalars["String"];
  id: Scalars["ID"];
  sender: Scalars["String"];
  token: Scalars["String"];
}

export interface LendingHistoryItem {
  __typename?: "LendingHistoryItem";
  amount: Scalars["String"];
  /** The underlying asset for this pool (eg USDT for the iUSDT pool) */
  asset?: Maybe<Token>;
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  lender: User;
  lendingPool: LendingPool;
  loanTokenAmount: Scalars["String"];
  transaction: Transaction;
  type: LendingHistoryType;
  userLendingHistory: UserLendingHistory;
}

export enum LendingHistoryType {
  Lend = "Lend",
  UnLend = "UnLend",
}

/** A Lending Pool (iToken), where Users can lend assets to earn interest, and Users can borrow assets to Margin Trade or just as a regular loan. */
export interface LendingPool {
  __typename?: "LendingPool";
  assetBalance: Scalars["String"];
  /** ID is the contract address of the iToken */
  id: Scalars["ID"];
  poolTokenBalance: Scalars["String"];
  /** Total asset volume lent over all time */
  totalAssetLent: Scalars["String"];
  /** The actual asset being lent and borrowed in this pool */
  underlyingAsset: Token;
}

/** Granular event data for the Loan entity. Emitted when a loan is fully or partially liquidated */
export interface Liquidate {
  __typename?: "Liquidate";
  collateralToLoanRate: Scalars["String"];
  collateralToken: Scalars["String"];
  collateralWithdrawAmount: Scalars["String"];
  currentMargin: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  lender: Scalars["String"];
  liquidator: Scalars["String"];
  loanId: Loan;
  loanToken: Scalars["String"];
  repayAmount: Scalars["String"];
  timestamp: Scalars["String"];
  transaction: Transaction;
  user: User;
}

export interface LiquidityHistoryItem {
  __typename?: "LiquidityHistoryItem";
  amount: Scalars["String"];
  emittedBy: Scalars["String"];
  /** ID is transaction hash + log index */
  id: Scalars["ID"];
  liquidityPool: LiquidityPool;
  newBalance: Scalars["String"];
  newSupply: Scalars["String"];
  provider: Scalars["String"];
  reserveToken: Token;
  timestamp: Scalars["String"];
  transaction: Transaction;
  type: LiquidityHistoryType;
  user: User;
  userLiquidityHistory: UserLiquidityHistory;
}

export enum LiquidityHistoryType {
  Added = "Added",
  Removed = "Removed",
}

/** AMM Pool (sometimes referred to as a Converter) */
export interface LiquidityPool {
  __typename?: "LiquidityPool";
  /** Activated with be true when this pool is activated, and will change to false is the pool is deactivated */
  activated?: Maybe<Scalars["Boolean"]>;
  connectorTokens: LiquidityPoolToken[];
  conversionFee?: Maybe<Scalars["String"]>;
  createdAtBlockNumber?: Maybe<Scalars["String"]>;
  createdAtTimestamp?: Maybe<Scalars["String"]>;
  createdAtTransaction: Transaction;
  currentConverterRegistry?: Maybe<ConverterRegistry>;
  /** ID is the contract address of the Converter */
  id: Scalars["ID"];
  lastResetBlockNumber?: Maybe<Scalars["String"]>;
  lastResetTimestamp?: Maybe<Scalars["String"]>;
  maxConversionFee?: Maybe<Scalars["String"]>;
  owner?: Maybe<Scalars["String"]>;
  poolTokens: TokenPoolToken[];
  smartToken?: Maybe<SmartToken>;
  /** The reserve assets of this AMM Pool. The are stored here like this so that they can be accessed inside mappings when the LiquidityPool is loaded. */
  token0?: Maybe<Token>;
  token1?: Maybe<Token>;
  /** Sovryn uses Bancor V1 and Bancor V2 pools */
  type?: Maybe<Scalars["Int"]>;
  version?: Maybe<Scalars["Int"]>;
  weight?: Maybe<Scalars["String"]>;
}

/** Autogenerated for debugging - to be eventually deleted */
export interface LiquidityPoolAdded {
  __typename?: "LiquidityPoolAdded";
  _liquidityPool: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  timestamp: Scalars["String"];
  transaction: Transaction;
}

/** Autogenerated for debugging - to be eventually deleted */
export interface LiquidityPoolRemoved {
  __typename?: "LiquidityPoolRemoved";
  _liquidityPool: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  timestamp: Scalars["String"];
  transaction: Transaction;
}

/**
 * This entity stores the relationship between liquidity pools and underlying tokens
 * It also currently stores the total volumes bought and so
 */
export interface LiquidityPoolToken {
  __typename?: "LiquidityPoolToken";
  /** ID is liquidityPool address + tokenAddress */
  id: Scalars["ID"];
  liquidityPool: LiquidityPool;
  /** The pool token that represents this token-liquidityPool relationship */
  poolToken: PoolToken;
  token: Token;
  totalVolume: Scalars["String"];
  volumeBought: Scalars["String"];
  volumeSold: Scalars["String"];
}

/** A Loan can be initialized by either a Margin Trade event or a Borrow event */
export interface Loan {
  __typename?: "Loan";
  /** Average price per token from all loan open events */
  averageBuyPrice: Scalars["String"];
  /** Average price per token from all loan close events */
  averageSellPrice: Scalars["String"];
  borrow?: Maybe<Borrow[]>;
  /** The amount borrowed in loan tokens */
  borrowedAmount: Scalars["String"];
  closeWithSwaps?: Maybe<CloseWithSwap[]>;
  closewithDeposits?: Maybe<CloseWithDeposit[]>;
  collateralToken: Token;
  depositCollateral?: Maybe<DepositCollateral[]>;
  endTimestamp?: Maybe<Scalars["String"]>;
  id: Scalars["ID"];
  /** If a Liquidate, CloseWithSwap or CloseWithDeposit event occurs with 0 margin or 0 leverage, this property changes to false */
  isOpen: Scalars["Boolean"];
  liquidates?: Maybe<Liquidate[]>;
  loanToken: Token;
  maxBorrowedAmount: Scalars["String"];
  /** The maximum this position size was - mainly for debugging purposes */
  maximumPositionSize: Scalars["String"];
  /** Total of collateral (user collateral in a Borrow, and user collateral + borrowed amount in a Trade) in collateral tokens */
  positionSize: Scalars["String"];
  /** The realized PnL is quoted in the collateral currency */
  realizedPnL: Scalars["String"];
  realizedPnLPercent: Scalars["String"];
  startBorrowedAmount: Scalars["String"];
  /** Initial size of the position */
  startPositionSize: Scalars["String"];
  /** The start rate of the loan in loan tokens (eg if it is a long USD/BTC margin trade, this is the BTC price in USD) */
  startRate: Scalars["String"];
  startTimestamp: Scalars["String"];
  /** Sum of position volume from Trade, Borrow and DepositCollateral events in this loan, in collateral token */
  totalBought: Scalars["String"];
  /** Sum of position change volume from CloseWithSwap, CloseWithDeposit and Liquidate events in this loan, in collateral token */
  totalSold: Scalars["String"];
  trade?: Maybe<Trade[]>;
  /** LoanType is either Trade (for Margin Trades) or Borrow (for Borrows) */
  type: LoanType;
  user: User;
}

export enum LoanType {
  Borrow = "Borrow",
  Trade = "Trade",
}

export interface MarginOrderCanceled {
  __typename?: "MarginOrderCanceled";
  emittedBy: Scalars["String"];
  hash: Scalars["String"];
  id: Scalars["ID"];
  timestamp: Scalars["String"];
  trader: Scalars["String"];
  transaction: Transaction;
}

export interface MarginOrderFilled {
  __typename?: "MarginOrderFilled";
  collateral: Scalars["String"];
  collateralTokenAddress: Scalars["String"];
  collateralTokenSent: Scalars["String"];
  emittedBy: Scalars["String"];
  filledPrice: Scalars["String"];
  hash: Scalars["String"];
  id: Scalars["ID"];
  leverageAmount: Scalars["String"];
  loanTokenAddress: Scalars["String"];
  loanTokenSent: Scalars["String"];
  principal: Scalars["String"];
  timestamp: Scalars["String"];
  trader: User;
  transaction: Transaction;
}

export interface NewConverter {
  __typename?: "NewConverter";
  _converter: Scalars["String"];
  _owner: Scalars["String"];
  _type: Scalars["Int"];
  id: Scalars["ID"];
  timestamp: Scalars["String"];
  transaction: Transaction;
}

export interface OrderCanceled {
  __typename?: "OrderCanceled";
  emittedBy: Scalars["String"];
  hash: Scalars["String"];
  id: Scalars["ID"];
  maker: Scalars["String"];
  timestamp: Scalars["String"];
  transaction: Transaction;
}

export interface OrderFilled {
  __typename?: "OrderFilled";
  amountIn: Scalars["String"];
  amountOut: Scalars["String"];
  emittedBy: Scalars["String"];
  filledPrice: Scalars["String"];
  hash: Scalars["String"];
  id: Scalars["ID"];
  maker: User;
  path: Array<Scalars["String"]>;
  timestamp: Scalars["String"];
  transaction: Transaction;
}

/** Granular event data for the Loan entity. Emitted when a user Borrows and when a loan is rolled over */
export interface PayBorrowingFee {
  __typename?: "PayBorrowingFee";
  amount: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  loanId: Loan;
  payer: Scalars["String"];
  timestamp: Scalars["String"];
  token: Scalars["String"];
  transaction: Transaction;
}

/** Granular event data for the Loan entity. Emitted when a user Lends or Unlends and when a loan is rolled over */
export interface PayLendingFee {
  __typename?: "PayLendingFee";
  amount: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  payer: Scalars["String"];
  timestamp: Scalars["String"];
  token: Scalars["String"];
  transaction: Transaction;
}

/** Granular event data for the Loan entity. Emitted when a user Margin Trades and when a loan is rolled over */
export interface PayTradingFee {
  __typename?: "PayTradingFee";
  amount: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  loanId: Loan;
  payer: Scalars["String"];
  timestamp: Scalars["String"];
  token: Scalars["String"];
  transaction: Transaction;
}

/** For the V1 pools, the pool token and smart token are the same. However, for V2 pools, there is one pool token per asset and only one smart token for the pool. */
export interface PoolToken {
  __typename?: "PoolToken";
  converters?: Maybe<LiquidityPoolToken[]>;
  decimals?: Maybe<Scalars["Int"]>;
  id: Scalars["ID"];
  name?: Maybe<Scalars["String"]>;
  symbol?: Maybe<Scalars["String"]>;
  underlyingAssets?: Maybe<TokenPoolToken[]>;
}

export interface Proposal {
  __typename?: "Proposal";
  canceled?: Maybe<Transaction>;
  countVotersAgainst: Scalars["String"];
  countVotersFor: Scalars["String"];
  created: Transaction;
  description: Scalars["String"];
  emittedBy: Scalars["String"];
  endBlock: Scalars["String"];
  executed?: Maybe<Transaction>;
  id: Scalars["ID"];
  proposalId: Scalars["String"];
  proposer: Scalars["String"];
  queued?: Maybe<Transaction>;
  signatures: Array<Scalars["String"]>;
  startBlock: Scalars["String"];
  targets: Array<Scalars["String"]>;
  timestamp: Scalars["String"];
  values: Array<Scalars["String"]>;
  votes?: Maybe<VoteCast[]>;
  votesAgainst: Scalars["String"];
  votesFor: Scalars["String"];
}

/**
 * This entity will have only one instance and will be used to store protocol-wide data like list of tokens and number or users.
 * The ID of this one entity is "0"
 */
export interface ProtocolStats {
  __typename?: "ProtocolStats";
  btcUsdPrice: Scalars["String"];
  /** Only one entity should be created, with ID "0" */
  id: Scalars["ID"];
  /** An array of all tokens in the protocol */
  tokens: Token[];
  /** Total volume of fees earned by liquidity providers to AMM pools (in usd) */
  totalAmmLpFeesUsd: Scalars["String"];
  /** Total volume of fees earned by SOV stakers from AMM conversion events (in usd). These fees began after the fee-sharing SIP was executed. */
  totalAmmStakerFeesUsd: Scalars["String"];
  /** Total volume that has passed through every AMM pool of the Sovryn protocol (in usd) */
  totalAmmVolumeUsd: Scalars["String"];
  /** Total of collateral property in Trade event (in usd). This may be changed to borrowed amount volume, but collateral keeps it consistent with margin trading */
  totalBorrowVolumeUsd: Scalars["String"];
  /** Total fees from Borrowing earned by SOV stakers (in usd) */
  totalBorrowingFeesUsd: Scalars["String"];
  /** Total volume of Borrows closed (in usd) */
  totalCloseWithDepositVolumeUsd: Scalars["String"];
  /** Total position volume closed for Margin Trades (in usd) */
  totalCloseWithSwapVolumeUsd: Scalars["String"];
  /** Total additional collateral deposited for Margin Trades and Borrows (in usd) */
  totalDepositCollateralVolumeUsd: Scalars["String"];
  /** Total volume supplied to Lending Pools over all time (in usd) */
  totalLendVolumeUsd: Scalars["String"];
  /** Total fees from Lending and Unlending earned by SOV stakers (in usd) */
  totalLendingFeesUsd: Scalars["String"];
  /** Total Margin Trade and Borrow position size that has been liquidated (in usd) */
  totalLiquidateVolumeUsd: Scalars["String"];
  /** Total of positionSize property in Trade event (in usd). This includes user collateral and borrowed amount */
  totalMarginTradeVolumeUsd: Scalars["String"];
  /** This is SOV staked by vesting contracts. It in incremented when the contracts stake the tokens, and decremented when users claim their unlocked tokens */
  totalStakedByVestingSov: Scalars["String"];
  /** Total fees from Margin Trading earned by SOV stakers (in usd) */
  totalTradingFeesUsd: Scalars["String"];
  /** NOT YET IMPLEMENTED: This will be a total of volumes of all transaction types (AMM Swaps, Margin Trades, CloseWithSwap etc etc) */
  totalTransactedVolumeUsd: Scalars["String"];
  /** Total volume withdrawn from Lending Pool over all time (in usd) */
  totalUnlendVolumeUsd: Scalars["String"];
  /**
   * Total number of users of the protocol. This number is incremented each time a user initiates a transaction with the Protocol.
   * Currently this is incremented by specific user actions, but could be incremented on a per Transaction basis.
   */
  totalUsers: Scalars["String"];
  /** This is SOV staked by users (not vesting contracts). It is incremented when users stake tokens, and decremented when users withdraw tokens from the staking contract */
  totalVoluntarilyStakedSov: Scalars["String"];
  usdStablecoin: Token;
}

export interface Query {
  __typename?: "Query";
  liquidityPool?: Maybe<LiquidityPool>;
  liquidityPools?: Maybe<Array<Maybe<LiquidityPool>>>;
  transaction?: Maybe<Transaction>;
  transactions?: Maybe<Array<Maybe<Transaction>>>;
}

export enum RewardsEarnedAction {
  EarnReward = "EarnReward",
  RewardClaimed = "RewardClaimed",
  RewardSovStaked = "RewardSovStaked",
  StakingRewardWithdrawn = "StakingRewardWithdrawn",
}

export interface RewardsEarnedHistoryItem {
  __typename?: "RewardsEarnedHistoryItem";
  action: RewardsEarnedAction;
  amount: Scalars["String"];
  id: Scalars["ID"];
  timestamp: Scalars["String"];
  token?: Maybe<Token>;
  transaction: Transaction;
  user: UserRewardsEarnedHistory;
}

/**
 * The smart token represents a single reserve asset on a single pool.
 * For V1 pools, there is 1 smart token representing both reserve assets. For V2 pools, there are 2 smart tokens, one for each reserve asset.
 */
export interface SmartToken {
  __typename?: "SmartToken";
  addedToRegistryBlockNumber?: Maybe<Scalars["String"]>;
  addedToRegistryTransactionHash?: Maybe<Scalars["String"]>;
  /** connectorTokens are the entity that holds the many-to-many relationship between the underlying token asset and the smart token */
  connectorTokens?: Maybe<TokenSmartToken[]>;
  currentConverterRegistry?: Maybe<ConverterRegistry>;
  decimals?: Maybe<Scalars["Int"]>;
  /** ID is smart token address */
  id: Scalars["ID"];
  /** The AMM pool this smart token "belongs" to */
  liquidityPool: LiquidityPool;
  name?: Maybe<Scalars["String"]>;
  owner: Scalars["String"];
  /** smartTokenType can be Relay or Liquid */
  smartTokenType?: Maybe<Scalars["String"]>;
  symbol?: Maybe<Scalars["String"]>;
  transfersEnabled?: Maybe<Scalars["Boolean"]>;
  version?: Maybe<Scalars["Int"]>;
}

/** Autogenerated for debugging - to be eventually deleted */
export interface SmartTokenAdded {
  __typename?: "SmartTokenAdded";
  _smartToken: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  timestamp: Scalars["String"];
  transaction: Transaction;
}

/** Autogenerated for debugging - to be eventually deleted */
export interface SmartTokenRemoved {
  __typename?: "SmartTokenRemoved";
  _smartToken: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  timestamp: Scalars["String"];
  transaction: Transaction;
}

export enum StakeHistoryAction {
  Delegate = "Delegate",
  ExtendStake = "ExtendStake",
  FeeWithdrawn = "FeeWithdrawn",
  IncreaseStake = "IncreaseStake",
  Stake = "Stake",
  Unstake = "Unstake",
  WithdrawStaked = "WithdrawStaked",
}

export interface StakeHistoryItem {
  __typename?: "StakeHistoryItem";
  action: StakeHistoryAction;
  amount?: Maybe<Scalars["String"]>;
  id: Scalars["ID"];
  lockedUntil?: Maybe<Scalars["String"]>;
  timestamp: Scalars["String"];
  transaction: Transaction;
  user: UserStakeHistory;
}

/**
 * The Swap entity is an aggregated entity of the individual Conversion events in a transaction.
 * For example, if a User swaps XUSD to SOV, there will be 2 Conversion events through 2 AMMs (XUSD-BTC and BTC-SOV) in one transaction. These two Conversions are aggregated here.
 */
export interface Swap {
  __typename?: "Swap";
  /** The AMM Conversion events involved in this swap */
  conversions?: Maybe<Conversion[]>;
  fromAmount: Scalars["String"];
  fromToken: Token;
  /** Transaction hash of this swap */
  id: Scalars["ID"];
  isBorrow: Scalars["Boolean"];
  /** Was this swap a limit order? */
  isLimit: Scalars["Boolean"];
  /** Was this swap part of a margin trade? */
  isMarginTrade: Scalars["Boolean"];
  /** The number of AMM Conversions involved in this swap (this is primarily for debugging purposes) */
  numConversions: Scalars["Int"];
  /** Rate is calculated as toAmount / fromAmount */
  rate: Scalars["String"];
  timestamp: Scalars["String"];
  toAmount: Scalars["String"];
  toToken: Token;
  transaction: Transaction;
  /** If this swap was initiated by a contract (for example as part of a Margin Trade), User will be null */
  user?: Maybe<User>;
}

/** This entity represents an ERC20 token traded on the Sovryn Protocol */
export interface Token {
  __typename?: "Token";
  /** The total volume of this token that has been traded through the protocol quoted in BTC */
  btcVolume: Scalars["String"];
  currentConverterRegistry?: Maybe<ConverterRegistry>;
  decimals?: Maybe<Scalars["Int"]>;
  /** Does this token have an AMM pool with rBTC as the other reserve asset? */
  hasBtcPool?: Maybe<Scalars["Boolean"]>;
  /** Does this token have an AMM pool with the protocol stablecoin as the other reserve asset? */
  hasStablecoinPool?: Maybe<Scalars["Boolean"]>;
  /** The ID is the contract address of the token on RSK */
  id: Scalars["ID"];
  lastPriceBtc: Scalars["String"];
  lastPriceUsd: Scalars["String"];
  /** The addresses of the LiquidityPools where this token is a reserve asset */
  liquidityPools?: Maybe<LiquidityPoolToken[]>;
  name?: Maybe<Scalars["String"]>;
  /** previous BTC price used for candleSticks */
  prevPriceBtc: Scalars["String"];
  /** previous BTC price used for candleSticks */
  prevPriceUsd: Scalars["String"];
  /** The smart tokens that have this token as an underlying asset */
  smartTokens?: Maybe<TokenSmartToken[]>;
  symbol?: Maybe<Scalars["String"]>;
  /** The total volume of this token that has been traded through the protocol */
  tokenVolume: Scalars["String"];
  /** The total volume of this token that has been traded through the protocol quoted in USD */
  usdVolume: Scalars["String"];
  version?: Maybe<Scalars["Int"]>;
}

/** The entity stores the many-to-many relationship between underlying tokens and pool tokens */
export interface TokenPoolToken {
  __typename?: "TokenPoolToken";
  /** ID is token address + poolToken address */
  id: Scalars["ID"];
  liquidityPool: LiquidityPool;
  poolToken: PoolToken;
  token: Token;
}

/** This entity is to store a many-to-many relationship between tokens and smart tokens */
export interface TokenSmartToken {
  __typename?: "TokenSmartToken";
  /** ID is token address + smart token address */
  id: Scalars["ID"];
  smartToken: SmartToken;
  /** token is the underlying asset represented by the smartToken */
  token: Token;
}

export interface TokensStaked {
  __typename?: "TokensStaked";
  amount: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  isUserStaked: Scalars["Boolean"];
  lockedUntil: Scalars["String"];
  staker: Scalars["String"];
  timestamp: Scalars["String"];
  totalStaked: Scalars["String"];
  transaction: Transaction;
  user?: Maybe<User>;
}

export interface Trade {
  __typename?: "Trade";
  borrowedAmount: Scalars["String"];
  collateralToken: Token;
  currentLeverage: Scalars["String"];
  emittedBy: Scalars["String"];
  entryLeverage: Scalars["String"];
  entryPrice: Scalars["String"];
  id: Scalars["ID"];
  interestRate: Scalars["String"];
  lender: Scalars["String"];
  loanId: Loan;
  loanToken: Token;
  positionSize: Scalars["String"];
  settlementDate: Scalars["String"];
  timestamp: Scalars["String"];
  transaction: Transaction;
  user: User;
}

/** Transaction data, including hash and timestamp */
export interface Transaction {
  __typename?: "Transaction";
  blockNumber: Scalars["String"];
  /** The account that initiated this transaction. This must be an Account and not a Contract. */
  from: Scalars["String"];
  gasLimit: Scalars["String"];
  gasPrice: Scalars["String"];
  /** ID is transaction hash */
  id: Scalars["ID"];
  /** The index of this transaction within the block */
  index: Scalars["String"];
  /** The timestamp the transaction was confirmed */
  timestamp: Scalars["String"];
  to?: Maybe<Scalars["String"]>;
  value: Scalars["String"];
}

/** This entity contains all user-specific data displayed on the dapp, including all user actions */
export interface User {
  __typename?: "User";
  /** An array of Borrow events */
  borrows?: Maybe<Borrow[]>;
  /** ID is user wallet address */
  id: Scalars["ID"];
  /** The lending history of a User, separated into lending pools. Explore the UserLendingHistory entity for more granular events. */
  lendingHistory?: Maybe<UserLendingHistory[]>;
  /** An array of Liquidation events linked to this user */
  liquidations?: Maybe<Liquidate[]>;
  /** An array of all LiquidityAdded and LiquidityRemoved events */
  liquidityHistory?: Maybe<UserLiquidityHistory[]>;
  /** All loans taken out by this user, including for margin trading and for borrowing */
  loans?: Maybe<Loan[]>;
  /**
   * The Rewards history of one user. This includes actions like EarnReward, RewardSovDeposited, and RewardSovStaked.
   * Explore the UserRewardsEarnedHistory entity for more granular events
   */
  rewardsEarnedHistory?: Maybe<UserRewardsEarnedHistory[]>;
  /** The SOV Staking history of a user. This includes withdrawing vested tokens. Explore the UserStakeHistory entity for more granular events. */
  stakeHistory?: Maybe<UserStakeHistory[]>;
  /**
   * Swaps here refers to only user-triggered swaps. For example, a swap that is part of a margin trade would not be included.
   * Swaps involving multiple amm pools are stored as a single swap, comprised of multiple Conversion events
   */
  swaps?: Maybe<Swap[]>;
  /** An array of margin trade Trade events */
  trades?: Maybe<Trade[]>;
  /** See UserTotals entity for full documentation */
  userTotals?: Maybe<UserTotal>;
  /** Vesting contracts owned by User, labelled by type */
  vestingContracts?: Maybe<VestingContract[]>;
  /** Voting history of User */
  votes?: Maybe<VoteCast[]>;
}

/** This entity contains the lending and unlending history of one User */
export interface UserLendingHistory {
  __typename?: "UserLendingHistory";
  /** ID is userAddress + lendingPoolAddress (lendingPool in this case is the lending pool token) */
  id: Scalars["ID"];
  /** Granular Lend/UnLend events. Derived from Mint/Burn events on the contracts */
  lendingHistory?: Maybe<LendingHistoryItem[]>;
  lendingPool: LendingPool;
  /** Total volume this User has lent to this pool over all time (in the underlying asset currency, ie rBTC for the rBTC lending pool) */
  totalLendVolume: Scalars["String"];
  /** Total volume this User has withdrawn from this pool over all time */
  totalUnlendVolume: Scalars["String"];
  user: User;
}

/** This entity stores one Users history of adding and removing liquidity from one AMM pool */
export interface UserLiquidityHistory {
  __typename?: "UserLiquidityHistory";
  id: Scalars["ID"];
  liquidityHistory?: Maybe<LiquidityHistoryItem[]>;
  poolToken: PoolToken;
  totalAsset0LiquidityAdded: Scalars["String"];
  totalAsset0LiquidityRemoved: Scalars["String"];
  totalAsset1LiquidityAdded: Scalars["String"];
  totalAsset1LiquidityRemoved: Scalars["String"];
  user: User;
}

/** This entity contains the history, fees and totals regarding one users' SOV rewards */
export interface UserRewardsEarnedHistory {
  __typename?: "UserRewardsEarnedHistory";
  /** This is incremented by EarnReward and RewardClaimed events, and set to 0 by RewardWithdrawn events */
  availableRewardSov: Scalars["String"];
  /** This is incremented by EarnReward events, and set to 0 by TokensStaked events on the LockedSOV contract */
  availableTradingRewards: Scalars["String"];
  id: Scalars["ID"];
  rewardsEarnedHistory?: Maybe<RewardsEarnedHistoryItem[]>;
  /** This is the total of all EarnReward and RewardClaimed events */
  totalFeesAndRewardsEarned: Scalars["String"];
  user: User;
}

export interface UserStakeHistory {
  __typename?: "UserStakeHistory";
  id: Scalars["ID"];
  stakeHistory?: Maybe<StakeHistoryItem[]>;
  totalRemaining: Scalars["String"];
  totalStaked: Scalars["String"];
  totalWithdrawn: Scalars["String"];
  user: User;
}

/** This is the total volumes of different actions for one user. See ProtocolStats entity for full descriptions. */
export interface UserTotal {
  __typename?: "UserTotal";
  id: Scalars["ID"];
  totalAmmLpFeesUsd: Scalars["String"];
  totalAmmStakerFeesUsd: Scalars["String"];
  totalAmmVolumeUsd: Scalars["String"];
  totalBorrowVolumeUsd: Scalars["String"];
  totalBorrowingFeesUsd: Scalars["String"];
  totalCloseWithDepositVolumeUsd: Scalars["String"];
  totalCloseWithSwapVolumeUsd: Scalars["String"];
  totalDepositCollateralVolumeUsd: Scalars["String"];
  totalLendVolumeUsd: Scalars["String"];
  totalLendingFeesUsd: Scalars["String"];
  totalLiquidateVolumeUsd: Scalars["String"];
  totalMarginTradeVolumeUsd: Scalars["String"];
  totalTradingFeesUsd: Scalars["String"];
  totalUnlendVolumeUsd: Scalars["String"];
  user: User;
}

export interface VestingContract {
  __typename?: "VestingContract";
  cliff?: Maybe<Scalars["String"]>;
  createdAtTimestamp: Scalars["String"];
  createdAtTransaction: Transaction;
  currentBalance: Scalars["String"];
  duration?: Maybe<Scalars["String"]>;
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  stakeHistory?: Maybe<VestingHistoryItem[]>;
  startingBalance: Scalars["String"];
  type: VestingContractType;
  user: User;
}

export enum VestingContractType {
  Fish = "Fish",
  FishTeam = "FishTeam",
  Genesis = "Genesis",
  Origins = "Origins",
  Rewards = "Rewards",
  Team = "Team",
}

export interface VestingHistoryItem {
  __typename?: "VestingHistoryItem";
  action: VestingHistoryItemAction;
  amount: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  lockedUntil: Scalars["String"];
  staker: VestingContract;
  timestamp: Scalars["String"];
  totalStaked: Scalars["String"];
  transaction: Transaction;
}

export enum VestingHistoryItemAction {
  TeamTokensRevoked = "TeamTokensRevoked",
  TokensStaked = "TokensStaked",
  TokensWithdrawn = "TokensWithdrawn",
}

export interface VoteCast {
  __typename?: "VoteCast";
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  proposal: Proposal;
  proposalId: Scalars["String"];
  support: Scalars["Boolean"];
  timestamp: Scalars["String"];
  transaction: Transaction;
  voter: User;
  votes: Scalars["String"];
}

export interface Withdrawal {
  __typename?: "Withdrawal";
  amount: Scalars["String"];
  emittedBy: Scalars["String"];
  id: Scalars["ID"];
  receiver: Scalars["String"];
  timestamp: Scalars["String"];
  transaction: Transaction;
}

export type ResolverTypeWrapper<T> = Promise<T> | T;

export interface ResolverWithResolve<TResult, TParent, TContext, TArgs> {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
}
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs
> {
  subscribe: SubscriptionSubscribeFn<
    { [key in TKey]: TResult },
    TParent,
    TContext,
    TArgs
  >;
  resolve?: SubscriptionResolveFn<
    TResult,
    { [key in TKey]: TResult },
    TContext,
    TArgs
  >;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs
> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<
  TResult,
  TKey extends string,
  TParent = {},
  TContext = {},
  TArgs = {}
> =
  | ((
      ...args: any[]
    ) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
  obj: T,
  context: TContext,
  info: GraphQLResolveInfo
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<
  TResult = {},
  TParent = {},
  TContext = {},
  TArgs = {}
> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export interface ResolversTypes {
  Boolean: ResolverTypeWrapper<Scalars["Boolean"]>;
  Borrow: ResolverTypeWrapper<Borrow>;
  CandleStick: ResolverTypeWrapper<CandleStick>;
  CandleSticksInterval: CandleSticksInterval;
  CloseWithDeposit: ResolverTypeWrapper<CloseWithDeposit>;
  CloseWithSwap: ResolverTypeWrapper<CloseWithSwap>;
  Conversion: ResolverTypeWrapper<Conversion>;
  ConverterRegistry: ResolverTypeWrapper<ConverterRegistry>;
  Deposit: ResolverTypeWrapper<Deposit>;
  DepositCollateral: ResolverTypeWrapper<DepositCollateral>;
  FeeSharingTokensTransferred: ResolverTypeWrapper<FeeSharingTokensTransferred>;
  ID: ResolverTypeWrapper<Scalars["ID"]>;
  Int: ResolverTypeWrapper<Scalars["Int"]>;
  LendingHistoryItem: ResolverTypeWrapper<LendingHistoryItem>;
  LendingHistoryType: LendingHistoryType;
  LendingPool: ResolverTypeWrapper<LendingPool>;
  Liquidate: ResolverTypeWrapper<Liquidate>;
  LiquidityHistoryItem: ResolverTypeWrapper<LiquidityHistoryItem>;
  LiquidityHistoryType: LiquidityHistoryType;
  LiquidityPool: ResolverTypeWrapper<LiquidityPool>;
  LiquidityPoolAdded: ResolverTypeWrapper<LiquidityPoolAdded>;
  LiquidityPoolRemoved: ResolverTypeWrapper<LiquidityPoolRemoved>;
  LiquidityPoolToken: ResolverTypeWrapper<LiquidityPoolToken>;
  Loan: ResolverTypeWrapper<Loan>;
  LoanType: LoanType;
  MarginOrderCanceled: ResolverTypeWrapper<MarginOrderCanceled>;
  MarginOrderFilled: ResolverTypeWrapper<MarginOrderFilled>;
  NewConverter: ResolverTypeWrapper<NewConverter>;
  OrderCanceled: ResolverTypeWrapper<OrderCanceled>;
  OrderFilled: ResolverTypeWrapper<OrderFilled>;
  PayBorrowingFee: ResolverTypeWrapper<PayBorrowingFee>;
  PayLendingFee: ResolverTypeWrapper<PayLendingFee>;
  PayTradingFee: ResolverTypeWrapper<PayTradingFee>;
  PoolToken: ResolverTypeWrapper<PoolToken>;
  Proposal: ResolverTypeWrapper<Proposal>;
  ProtocolStats: ResolverTypeWrapper<ProtocolStats>;
  Query: ResolverTypeWrapper<{}>;
  RewardsEarnedAction: RewardsEarnedAction;
  RewardsEarnedHistoryItem: ResolverTypeWrapper<RewardsEarnedHistoryItem>;
  SmartToken: ResolverTypeWrapper<SmartToken>;
  SmartTokenAdded: ResolverTypeWrapper<SmartTokenAdded>;
  SmartTokenRemoved: ResolverTypeWrapper<SmartTokenRemoved>;
  StakeHistoryAction: StakeHistoryAction;
  StakeHistoryItem: ResolverTypeWrapper<StakeHistoryItem>;
  String: ResolverTypeWrapper<Scalars["String"]>;
  Swap: ResolverTypeWrapper<Swap>;
  Token: ResolverTypeWrapper<Token>;
  TokenPoolToken: ResolverTypeWrapper<TokenPoolToken>;
  TokenSmartToken: ResolverTypeWrapper<TokenSmartToken>;
  TokensStaked: ResolverTypeWrapper<TokensStaked>;
  Trade: ResolverTypeWrapper<Trade>;
  Transaction: ResolverTypeWrapper<Transaction>;
  User: ResolverTypeWrapper<User>;
  UserLendingHistory: ResolverTypeWrapper<UserLendingHistory>;
  UserLiquidityHistory: ResolverTypeWrapper<UserLiquidityHistory>;
  UserRewardsEarnedHistory: ResolverTypeWrapper<UserRewardsEarnedHistory>;
  UserStakeHistory: ResolverTypeWrapper<UserStakeHistory>;
  UserTotal: ResolverTypeWrapper<UserTotal>;
  VestingContract: ResolverTypeWrapper<VestingContract>;
  VestingContractType: VestingContractType;
  VestingHistoryItem: ResolverTypeWrapper<VestingHistoryItem>;
  VestingHistoryItemAction: VestingHistoryItemAction;
  VoteCast: ResolverTypeWrapper<VoteCast>;
  Withdrawal: ResolverTypeWrapper<Withdrawal>;
}

/** Mapping between all available schema types and the resolvers parents */
export interface ResolversParentTypes {
  Boolean: Scalars["Boolean"];
  Borrow: Borrow;
  CandleStick: CandleStick;
  CloseWithDeposit: CloseWithDeposit;
  CloseWithSwap: CloseWithSwap;
  Conversion: Conversion;
  ConverterRegistry: ConverterRegistry;
  Deposit: Deposit;
  DepositCollateral: DepositCollateral;
  FeeSharingTokensTransferred: FeeSharingTokensTransferred;
  ID: Scalars["ID"];
  Int: Scalars["Int"];
  LendingHistoryItem: LendingHistoryItem;
  LendingPool: LendingPool;
  Liquidate: Liquidate;
  LiquidityHistoryItem: LiquidityHistoryItem;
  LiquidityPool: LiquidityPool;
  LiquidityPoolAdded: LiquidityPoolAdded;
  LiquidityPoolRemoved: LiquidityPoolRemoved;
  LiquidityPoolToken: LiquidityPoolToken;
  Loan: Loan;
  MarginOrderCanceled: MarginOrderCanceled;
  MarginOrderFilled: MarginOrderFilled;
  NewConverter: NewConverter;
  OrderCanceled: OrderCanceled;
  OrderFilled: OrderFilled;
  PayBorrowingFee: PayBorrowingFee;
  PayLendingFee: PayLendingFee;
  PayTradingFee: PayTradingFee;
  PoolToken: PoolToken;
  Proposal: Proposal;
  ProtocolStats: ProtocolStats;
  Query: {};
  RewardsEarnedHistoryItem: RewardsEarnedHistoryItem;
  SmartToken: SmartToken;
  SmartTokenAdded: SmartTokenAdded;
  SmartTokenRemoved: SmartTokenRemoved;
  StakeHistoryItem: StakeHistoryItem;
  String: Scalars["String"];
  Swap: Swap;
  Token: Token;
  TokenPoolToken: TokenPoolToken;
  TokenSmartToken: TokenSmartToken;
  TokensStaked: TokensStaked;
  Trade: Trade;
  Transaction: Transaction;
  User: User;
  UserLendingHistory: UserLendingHistory;
  UserLiquidityHistory: UserLiquidityHistory;
  UserRewardsEarnedHistory: UserRewardsEarnedHistory;
  UserStakeHistory: UserStakeHistory;
  UserTotal: UserTotal;
  VestingContract: VestingContract;
  VestingHistoryItem: VestingHistoryItem;
  VoteCast: VoteCast;
  Withdrawal: Withdrawal;
}

export interface BorrowResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Borrow"] = ResolversParentTypes["Borrow"]
> {
  collateralToLoanRate?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  collateralToken?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  currentMargin?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  interestDuration?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  interestRate?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  lender?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  loanId?: Resolver<ResolversTypes["Loan"], ParentType, ContextType>;
  loanToken?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  newCollateral?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  newPrincipal?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface CandleStickResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["CandleStick"] = ResolversParentTypes["CandleStick"]
> {
  baseToken?: Resolver<Maybe<ResolversTypes["Token"]>, ParentType, ContextType>;
  close?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  high?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  interval?: Resolver<
    Maybe<ResolversTypes["CandleSticksInterval"]>,
    ParentType,
    ContextType
  >;
  low?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  open?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  periodStartUnix?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  quoteToken?: Resolver<
    Maybe<ResolversTypes["Token"]>,
    ParentType,
    ContextType
  >;
  totalVolume?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  txCount?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface CloseWithDepositResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["CloseWithDeposit"] = ResolversParentTypes["CloseWithDeposit"]
> {
  closer?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  collateralToLoanRate?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  collateralToken?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  collateralWithdrawAmount?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  currentMargin?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  lender?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  loanId?: Resolver<ResolversTypes["Loan"], ParentType, ContextType>;
  loanToken?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  repayAmount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface CloseWithSwapResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["CloseWithSwap"] = ResolversParentTypes["CloseWithSwap"]
> {
  closer?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  collateralToken?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  currentLeverage?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  exitPrice?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  lender?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  loanCloseAmount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  loanId?: Resolver<ResolversTypes["Loan"], ParentType, ContextType>;
  loanToken?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  positionCloseSize?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface ConversionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Conversion"] = ResolversParentTypes["Conversion"]
> {
  _amount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  _conversionFee?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  _fromToken?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  _protocolFee?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  _return?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  _toToken?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  _trader?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  swapTransaction?: Resolver<ResolversTypes["Swap"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface ConverterRegistryResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["ConverterRegistry"] = ResolversParentTypes["ConverterRegistry"]
> {
  addedToContractRegistryAtBlockNumber?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  addedToContractRegistryAtBlockTimestamp?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  addedToContractRegistryAtTransactionHash?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  connectorTokens?: Resolver<
    Maybe<Array<ResolversTypes["Token"]>>,
    ParentType,
    ContextType
  >;
  converters?: Resolver<
    Maybe<Array<ResolversTypes["LiquidityPool"]>>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  lastUsedAtBlockNumber?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  lastUsedAtBlockTimestamp?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  lastUsedAtTransactionHash?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  numConverters?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  owner?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  smartTokens?: Resolver<
    Maybe<Array<ResolversTypes["SmartToken"]>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface DepositResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Deposit"] = ResolversParentTypes["Deposit"]
> {
  amount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  to?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface DepositCollateralResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["DepositCollateral"] = ResolversParentTypes["DepositCollateral"]
> {
  depositAmount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  loanId?: Resolver<ResolversTypes["Loan"], ParentType, ContextType>;
  rate?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface FeeSharingTokensTransferredResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["FeeSharingTokensTransferred"] = ResolversParentTypes["FeeSharingTokensTransferred"]
> {
  amount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  sender?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface LendingHistoryItemResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["LendingHistoryItem"] = ResolversParentTypes["LendingHistoryItem"]
> {
  amount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  asset?: Resolver<Maybe<ResolversTypes["Token"]>, ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  lender?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  lendingPool?: Resolver<
    ResolversTypes["LendingPool"],
    ParentType,
    ContextType
  >;
  loanTokenAmount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  type?: Resolver<
    ResolversTypes["LendingHistoryType"],
    ParentType,
    ContextType
  >;
  userLendingHistory?: Resolver<
    ResolversTypes["UserLendingHistory"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface LendingPoolResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["LendingPool"] = ResolversParentTypes["LendingPool"]
> {
  assetBalance?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  poolTokenBalance?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalAssetLent?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  underlyingAsset?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface LiquidateResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Liquidate"] = ResolversParentTypes["Liquidate"]
> {
  collateralToLoanRate?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  collateralToken?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  collateralWithdrawAmount?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  currentMargin?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  lender?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  liquidator?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  loanId?: Resolver<ResolversTypes["Loan"], ParentType, ContextType>;
  loanToken?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  repayAmount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface LiquidityHistoryItemResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["LiquidityHistoryItem"] = ResolversParentTypes["LiquidityHistoryItem"]
> {
  amount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  liquidityPool?: Resolver<
    ResolversTypes["LiquidityPool"],
    ParentType,
    ContextType
  >;
  newBalance?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  newSupply?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  provider?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  reserveToken?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  type?: Resolver<
    ResolversTypes["LiquidityHistoryType"],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  userLiquidityHistory?: Resolver<
    ResolversTypes["UserLiquidityHistory"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface LiquidityPoolResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["LiquidityPool"] = ResolversParentTypes["LiquidityPool"]
> {
  activated?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  connectorTokens?: Resolver<
    Array<ResolversTypes["LiquidityPoolToken"]>,
    ParentType,
    ContextType
  >;
  conversionFee?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  createdAtBlockNumber?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  createdAtTimestamp?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  createdAtTransaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  currentConverterRegistry?: Resolver<
    Maybe<ResolversTypes["ConverterRegistry"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  lastResetBlockNumber?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  lastResetTimestamp?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  maxConversionFee?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  owner?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  poolTokens?: Resolver<
    Array<ResolversTypes["TokenPoolToken"]>,
    ParentType,
    ContextType
  >;
  smartToken?: Resolver<
    Maybe<ResolversTypes["SmartToken"]>,
    ParentType,
    ContextType
  >;
  token0?: Resolver<Maybe<ResolversTypes["Token"]>, ParentType, ContextType>;
  token1?: Resolver<Maybe<ResolversTypes["Token"]>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  weight?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface LiquidityPoolAddedResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["LiquidityPoolAdded"] = ResolversParentTypes["LiquidityPoolAdded"]
> {
  _liquidityPool?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface LiquidityPoolRemovedResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["LiquidityPoolRemoved"] = ResolversParentTypes["LiquidityPoolRemoved"]
> {
  _liquidityPool?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface LiquidityPoolTokenResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["LiquidityPoolToken"] = ResolversParentTypes["LiquidityPoolToken"]
> {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  liquidityPool?: Resolver<
    ResolversTypes["LiquidityPool"],
    ParentType,
    ContextType
  >;
  poolToken?: Resolver<ResolversTypes["PoolToken"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  totalVolume?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  volumeBought?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  volumeSold?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface LoanResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Loan"] = ResolversParentTypes["Loan"]
> {
  averageBuyPrice?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  averageSellPrice?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  borrow?: Resolver<
    Maybe<Array<ResolversTypes["Borrow"]>>,
    ParentType,
    ContextType
  >;
  borrowedAmount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  closeWithSwaps?: Resolver<
    Maybe<Array<ResolversTypes["CloseWithSwap"]>>,
    ParentType,
    ContextType
  >;
  closewithDeposits?: Resolver<
    Maybe<Array<ResolversTypes["CloseWithDeposit"]>>,
    ParentType,
    ContextType
  >;
  collateralToken?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  depositCollateral?: Resolver<
    Maybe<Array<ResolversTypes["DepositCollateral"]>>,
    ParentType,
    ContextType
  >;
  endTimestamp?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isOpen?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  liquidates?: Resolver<
    Maybe<Array<ResolversTypes["Liquidate"]>>,
    ParentType,
    ContextType
  >;
  loanToken?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  maxBorrowedAmount?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  maximumPositionSize?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  positionSize?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  realizedPnL?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  realizedPnLPercent?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  startBorrowedAmount?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  startPositionSize?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  startRate?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  startTimestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  totalBought?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  totalSold?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  trade?: Resolver<
    Maybe<Array<ResolversTypes["Trade"]>>,
    ParentType,
    ContextType
  >;
  type?: Resolver<ResolversTypes["LoanType"], ParentType, ContextType>;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface MarginOrderCanceledResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["MarginOrderCanceled"] = ResolversParentTypes["MarginOrderCanceled"]
> {
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  hash?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  trader?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface MarginOrderFilledResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["MarginOrderFilled"] = ResolversParentTypes["MarginOrderFilled"]
> {
  collateral?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  collateralTokenAddress?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  collateralTokenSent?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  filledPrice?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  hash?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  leverageAmount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  loanTokenAddress?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  loanTokenSent?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  principal?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  trader?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface NewConverterResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["NewConverter"] = ResolversParentTypes["NewConverter"]
> {
  _converter?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  _owner?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  _type?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface OrderCanceledResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["OrderCanceled"] = ResolversParentTypes["OrderCanceled"]
> {
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  hash?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  maker?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface OrderFilledResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["OrderFilled"] = ResolversParentTypes["OrderFilled"]
> {
  amountIn?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  amountOut?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  filledPrice?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  hash?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  maker?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  path?: Resolver<Array<ResolversTypes["String"]>, ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface PayBorrowingFeeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PayBorrowingFee"] = ResolversParentTypes["PayBorrowingFee"]
> {
  amount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  loanId?: Resolver<ResolversTypes["Loan"], ParentType, ContextType>;
  payer?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface PayLendingFeeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PayLendingFee"] = ResolversParentTypes["PayLendingFee"]
> {
  amount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  payer?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface PayTradingFeeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PayTradingFee"] = ResolversParentTypes["PayTradingFee"]
> {
  amount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  loanId?: Resolver<ResolversTypes["Loan"], ParentType, ContextType>;
  payer?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface PoolTokenResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["PoolToken"] = ResolversParentTypes["PoolToken"]
> {
  converters?: Resolver<
    Maybe<Array<ResolversTypes["LiquidityPoolToken"]>>,
    ParentType,
    ContextType
  >;
  decimals?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  symbol?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  underlyingAssets?: Resolver<
    Maybe<Array<ResolversTypes["TokenPoolToken"]>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface ProposalResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Proposal"] = ResolversParentTypes["Proposal"]
> {
  canceled?: Resolver<
    Maybe<ResolversTypes["Transaction"]>,
    ParentType,
    ContextType
  >;
  countVotersAgainst?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  countVotersFor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  created?: Resolver<ResolversTypes["Transaction"], ParentType, ContextType>;
  description?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  endBlock?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  executed?: Resolver<
    Maybe<ResolversTypes["Transaction"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  proposalId?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  proposer?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  queued?: Resolver<
    Maybe<ResolversTypes["Transaction"]>,
    ParentType,
    ContextType
  >;
  signatures?: Resolver<
    Array<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  startBlock?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  targets?: Resolver<Array<ResolversTypes["String"]>, ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  values?: Resolver<Array<ResolversTypes["String"]>, ParentType, ContextType>;
  votes?: Resolver<
    Maybe<Array<ResolversTypes["VoteCast"]>>,
    ParentType,
    ContextType
  >;
  votesAgainst?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  votesFor?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface ProtocolStatsResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["ProtocolStats"] = ResolversParentTypes["ProtocolStats"]
> {
  btcUsdPrice?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  tokens?: Resolver<Array<ResolversTypes["Token"]>, ParentType, ContextType>;
  totalAmmLpFeesUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalAmmStakerFeesUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalAmmVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalBorrowVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalBorrowingFeesUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalCloseWithDepositVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalCloseWithSwapVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalDepositCollateralVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalLendVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalLendingFeesUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalLiquidateVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalMarginTradeVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalStakedByVestingSov?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalTradingFeesUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalTransactedVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalUnlendVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalUsers?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  totalVoluntarilyStakedSov?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  usdStablecoin?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface QueryResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Query"] = ResolversParentTypes["Query"]
> {
  liquidityPool?: Resolver<
    Maybe<ResolversTypes["LiquidityPool"]>,
    ParentType,
    ContextType
  >;
  liquidityPools?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["LiquidityPool"]>>>,
    ParentType,
    ContextType
  >;
  transaction?: Resolver<
    Maybe<ResolversTypes["Transaction"]>,
    ParentType,
    ContextType
  >;
  transactions?: Resolver<
    Maybe<Array<Maybe<ResolversTypes["Transaction"]>>>,
    ParentType,
    ContextType
  >;
}

export interface RewardsEarnedHistoryItemResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["RewardsEarnedHistoryItem"] = ResolversParentTypes["RewardsEarnedHistoryItem"]
> {
  action?: Resolver<
    ResolversTypes["RewardsEarnedAction"],
    ParentType,
    ContextType
  >;
  amount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  token?: Resolver<Maybe<ResolversTypes["Token"]>, ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  user?: Resolver<
    ResolversTypes["UserRewardsEarnedHistory"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface SmartTokenResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["SmartToken"] = ResolversParentTypes["SmartToken"]
> {
  addedToRegistryBlockNumber?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  addedToRegistryTransactionHash?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  connectorTokens?: Resolver<
    Maybe<Array<ResolversTypes["TokenSmartToken"]>>,
    ParentType,
    ContextType
  >;
  currentConverterRegistry?: Resolver<
    Maybe<ResolversTypes["ConverterRegistry"]>,
    ParentType,
    ContextType
  >;
  decimals?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  liquidityPool?: Resolver<
    ResolversTypes["LiquidityPool"],
    ParentType,
    ContextType
  >;
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  owner?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  smartTokenType?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  symbol?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  transfersEnabled?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  version?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface SmartTokenAddedResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["SmartTokenAdded"] = ResolversParentTypes["SmartTokenAdded"]
> {
  _smartToken?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface SmartTokenRemovedResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["SmartTokenRemoved"] = ResolversParentTypes["SmartTokenRemoved"]
> {
  _smartToken?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface StakeHistoryItemResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["StakeHistoryItem"] = ResolversParentTypes["StakeHistoryItem"]
> {
  action?: Resolver<
    ResolversTypes["StakeHistoryAction"],
    ParentType,
    ContextType
  >;
  amount?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  lockedUntil?: Resolver<
    Maybe<ResolversTypes["String"]>,
    ParentType,
    ContextType
  >;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes["UserStakeHistory"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface SwapResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Swap"] = ResolversParentTypes["Swap"]
> {
  conversions?: Resolver<
    Maybe<Array<ResolversTypes["Conversion"]>>,
    ParentType,
    ContextType
  >;
  fromAmount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  fromToken?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isBorrow?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isLimit?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  isMarginTrade?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  numConversions?: Resolver<ResolversTypes["Int"], ParentType, ContextType>;
  rate?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  toAmount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  toToken?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface TokenResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Token"] = ResolversParentTypes["Token"]
> {
  btcVolume?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  currentConverterRegistry?: Resolver<
    Maybe<ResolversTypes["ConverterRegistry"]>,
    ParentType,
    ContextType
  >;
  decimals?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  hasBtcPool?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  hasStablecoinPool?: Resolver<
    Maybe<ResolversTypes["Boolean"]>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  lastPriceBtc?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  lastPriceUsd?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  liquidityPools?: Resolver<
    Maybe<Array<ResolversTypes["LiquidityPoolToken"]>>,
    ParentType,
    ContextType
  >;
  name?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  prevPriceBtc?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  prevPriceUsd?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  smartTokens?: Resolver<
    Maybe<Array<ResolversTypes["TokenSmartToken"]>>,
    ParentType,
    ContextType
  >;
  symbol?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  tokenVolume?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  usdVolume?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes["Int"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface TokenPoolTokenResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["TokenPoolToken"] = ResolversParentTypes["TokenPoolToken"]
> {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  liquidityPool?: Resolver<
    ResolversTypes["LiquidityPool"],
    ParentType,
    ContextType
  >;
  poolToken?: Resolver<ResolversTypes["PoolToken"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface TokenSmartTokenResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["TokenSmartToken"] = ResolversParentTypes["TokenSmartToken"]
> {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  smartToken?: Resolver<ResolversTypes["SmartToken"], ParentType, ContextType>;
  token?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface TokensStakedResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["TokensStaked"] = ResolversParentTypes["TokensStaked"]
> {
  amount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  isUserStaked?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  lockedUntil?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  staker?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  totalStaked?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  user?: Resolver<Maybe<ResolversTypes["User"]>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface TradeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Trade"] = ResolversParentTypes["Trade"]
> {
  borrowedAmount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  collateralToken?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  currentLeverage?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  entryLeverage?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  entryPrice?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  interestRate?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  lender?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  loanId?: Resolver<ResolversTypes["Loan"], ParentType, ContextType>;
  loanToken?: Resolver<ResolversTypes["Token"], ParentType, ContextType>;
  positionSize?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  settlementDate?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface TransactionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Transaction"] = ResolversParentTypes["Transaction"]
> {
  blockNumber?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  from?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  gasLimit?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  gasPrice?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  index?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  to?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface UserResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["User"] = ResolversParentTypes["User"]
> {
  borrows?: Resolver<
    Maybe<Array<ResolversTypes["Borrow"]>>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  lendingHistory?: Resolver<
    Maybe<Array<ResolversTypes["UserLendingHistory"]>>,
    ParentType,
    ContextType
  >;
  liquidations?: Resolver<
    Maybe<Array<ResolversTypes["Liquidate"]>>,
    ParentType,
    ContextType
  >;
  liquidityHistory?: Resolver<
    Maybe<Array<ResolversTypes["UserLiquidityHistory"]>>,
    ParentType,
    ContextType
  >;
  loans?: Resolver<
    Maybe<Array<ResolversTypes["Loan"]>>,
    ParentType,
    ContextType
  >;
  rewardsEarnedHistory?: Resolver<
    Maybe<Array<ResolversTypes["UserRewardsEarnedHistory"]>>,
    ParentType,
    ContextType
  >;
  stakeHistory?: Resolver<
    Maybe<Array<ResolversTypes["UserStakeHistory"]>>,
    ParentType,
    ContextType
  >;
  swaps?: Resolver<
    Maybe<Array<ResolversTypes["Swap"]>>,
    ParentType,
    ContextType
  >;
  trades?: Resolver<
    Maybe<Array<ResolversTypes["Trade"]>>,
    ParentType,
    ContextType
  >;
  userTotals?: Resolver<
    Maybe<ResolversTypes["UserTotal"]>,
    ParentType,
    ContextType
  >;
  vestingContracts?: Resolver<
    Maybe<Array<ResolversTypes["VestingContract"]>>,
    ParentType,
    ContextType
  >;
  votes?: Resolver<
    Maybe<Array<ResolversTypes["VoteCast"]>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface UserLendingHistoryResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["UserLendingHistory"] = ResolversParentTypes["UserLendingHistory"]
> {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  lendingHistory?: Resolver<
    Maybe<Array<ResolversTypes["LendingHistoryItem"]>>,
    ParentType,
    ContextType
  >;
  lendingPool?: Resolver<
    ResolversTypes["LendingPool"],
    ParentType,
    ContextType
  >;
  totalLendVolume?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  totalUnlendVolume?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface UserLiquidityHistoryResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["UserLiquidityHistory"] = ResolversParentTypes["UserLiquidityHistory"]
> {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  liquidityHistory?: Resolver<
    Maybe<Array<ResolversTypes["LiquidityHistoryItem"]>>,
    ParentType,
    ContextType
  >;
  poolToken?: Resolver<ResolversTypes["PoolToken"], ParentType, ContextType>;
  totalAsset0LiquidityAdded?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalAsset0LiquidityRemoved?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalAsset1LiquidityAdded?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalAsset1LiquidityRemoved?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface UserRewardsEarnedHistoryResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["UserRewardsEarnedHistory"] = ResolversParentTypes["UserRewardsEarnedHistory"]
> {
  availableRewardSov?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  availableTradingRewards?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  rewardsEarnedHistory?: Resolver<
    Maybe<Array<ResolversTypes["RewardsEarnedHistoryItem"]>>,
    ParentType,
    ContextType
  >;
  totalFeesAndRewardsEarned?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface UserStakeHistoryResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["UserStakeHistory"] = ResolversParentTypes["UserStakeHistory"]
> {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  stakeHistory?: Resolver<
    Maybe<Array<ResolversTypes["StakeHistoryItem"]>>,
    ParentType,
    ContextType
  >;
  totalRemaining?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  totalStaked?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  totalWithdrawn?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface UserTotalResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["UserTotal"] = ResolversParentTypes["UserTotal"]
> {
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  totalAmmLpFeesUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalAmmStakerFeesUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalAmmVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalBorrowVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalBorrowingFeesUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalCloseWithDepositVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalCloseWithSwapVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalDepositCollateralVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalLendVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalLendingFeesUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalLiquidateVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalMarginTradeVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalTradingFeesUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  totalUnlendVolumeUsd?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface VestingContractResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["VestingContract"] = ResolversParentTypes["VestingContract"]
> {
  cliff?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  createdAtTimestamp?: Resolver<
    ResolversTypes["String"],
    ParentType,
    ContextType
  >;
  createdAtTransaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  currentBalance?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  duration?: Resolver<Maybe<ResolversTypes["String"]>, ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  stakeHistory?: Resolver<
    Maybe<Array<ResolversTypes["VestingHistoryItem"]>>,
    ParentType,
    ContextType
  >;
  startingBalance?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  type?: Resolver<
    ResolversTypes["VestingContractType"],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface VestingHistoryItemResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["VestingHistoryItem"] = ResolversParentTypes["VestingHistoryItem"]
> {
  action?: Resolver<
    ResolversTypes["VestingHistoryItemAction"],
    ParentType,
    ContextType
  >;
  amount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  lockedUntil?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  staker?: Resolver<ResolversTypes["VestingContract"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  totalStaked?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface VoteCastResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["VoteCast"] = ResolversParentTypes["VoteCast"]
> {
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  proposal?: Resolver<ResolversTypes["Proposal"], ParentType, ContextType>;
  proposalId?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  support?: Resolver<ResolversTypes["Boolean"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  voter?: Resolver<ResolversTypes["User"], ParentType, ContextType>;
  votes?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface WithdrawalResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes["Withdrawal"] = ResolversParentTypes["Withdrawal"]
> {
  amount?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  emittedBy?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  id?: Resolver<ResolversTypes["ID"], ParentType, ContextType>;
  receiver?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes["String"], ParentType, ContextType>;
  transaction?: Resolver<
    ResolversTypes["Transaction"],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}

export interface Resolvers<ContextType = any> {
  Borrow?: BorrowResolvers<ContextType>;
  CandleStick?: CandleStickResolvers<ContextType>;
  CloseWithDeposit?: CloseWithDepositResolvers<ContextType>;
  CloseWithSwap?: CloseWithSwapResolvers<ContextType>;
  Conversion?: ConversionResolvers<ContextType>;
  ConverterRegistry?: ConverterRegistryResolvers<ContextType>;
  Deposit?: DepositResolvers<ContextType>;
  DepositCollateral?: DepositCollateralResolvers<ContextType>;
  FeeSharingTokensTransferred?: FeeSharingTokensTransferredResolvers<ContextType>;
  LendingHistoryItem?: LendingHistoryItemResolvers<ContextType>;
  LendingPool?: LendingPoolResolvers<ContextType>;
  Liquidate?: LiquidateResolvers<ContextType>;
  LiquidityHistoryItem?: LiquidityHistoryItemResolvers<ContextType>;
  LiquidityPool?: LiquidityPoolResolvers<ContextType>;
  LiquidityPoolAdded?: LiquidityPoolAddedResolvers<ContextType>;
  LiquidityPoolRemoved?: LiquidityPoolRemovedResolvers<ContextType>;
  LiquidityPoolToken?: LiquidityPoolTokenResolvers<ContextType>;
  Loan?: LoanResolvers<ContextType>;
  MarginOrderCanceled?: MarginOrderCanceledResolvers<ContextType>;
  MarginOrderFilled?: MarginOrderFilledResolvers<ContextType>;
  NewConverter?: NewConverterResolvers<ContextType>;
  OrderCanceled?: OrderCanceledResolvers<ContextType>;
  OrderFilled?: OrderFilledResolvers<ContextType>;
  PayBorrowingFee?: PayBorrowingFeeResolvers<ContextType>;
  PayLendingFee?: PayLendingFeeResolvers<ContextType>;
  PayTradingFee?: PayTradingFeeResolvers<ContextType>;
  PoolToken?: PoolTokenResolvers<ContextType>;
  Proposal?: ProposalResolvers<ContextType>;
  ProtocolStats?: ProtocolStatsResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  RewardsEarnedHistoryItem?: RewardsEarnedHistoryItemResolvers<ContextType>;
  SmartToken?: SmartTokenResolvers<ContextType>;
  SmartTokenAdded?: SmartTokenAddedResolvers<ContextType>;
  SmartTokenRemoved?: SmartTokenRemovedResolvers<ContextType>;
  StakeHistoryItem?: StakeHistoryItemResolvers<ContextType>;
  Swap?: SwapResolvers<ContextType>;
  Token?: TokenResolvers<ContextType>;
  TokenPoolToken?: TokenPoolTokenResolvers<ContextType>;
  TokenSmartToken?: TokenSmartTokenResolvers<ContextType>;
  TokensStaked?: TokensStakedResolvers<ContextType>;
  Trade?: TradeResolvers<ContextType>;
  Transaction?: TransactionResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserLendingHistory?: UserLendingHistoryResolvers<ContextType>;
  UserLiquidityHistory?: UserLiquidityHistoryResolvers<ContextType>;
  UserRewardsEarnedHistory?: UserRewardsEarnedHistoryResolvers<ContextType>;
  UserStakeHistory?: UserStakeHistoryResolvers<ContextType>;
  UserTotal?: UserTotalResolvers<ContextType>;
  VestingContract?: VestingContractResolvers<ContextType>;
  VestingHistoryItem?: VestingHistoryItemResolvers<ContextType>;
  VoteCast?: VoteCastResolvers<ContextType>;
  Withdrawal?: WithdrawalResolvers<ContextType>;
}
